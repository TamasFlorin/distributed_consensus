// This file is generated by rust-protobuf 2.11.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `message.proto`

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_11_0;

#[derive(PartialEq,Clone,Default)]
pub struct ProcessId {
    // message fields
    pub host: ::std::string::String,
    pub port: i32,
    pub owner: ::std::string::String,
    pub index: i32,
    pub rank: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ProcessId {
    fn default() -> &'a ProcessId {
        <ProcessId as ::protobuf::Message>::default_instance()
    }
}

impl ProcessId {
    pub fn new() -> ProcessId {
        ::std::default::Default::default()
    }

    // string host = 1;


    pub fn get_host(&self) -> &str {
        &self.host
    }
    pub fn clear_host(&mut self) {
        self.host.clear();
    }

    // Param is passed by value, moved
    pub fn set_host(&mut self, v: ::std::string::String) {
        self.host = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_host(&mut self) -> &mut ::std::string::String {
        &mut self.host
    }

    // Take field
    pub fn take_host(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.host, ::std::string::String::new())
    }

    // int32 port = 2;


    pub fn get_port(&self) -> i32 {
        self.port
    }
    pub fn clear_port(&mut self) {
        self.port = 0;
    }

    // Param is passed by value, moved
    pub fn set_port(&mut self, v: i32) {
        self.port = v;
    }

    // string owner = 3;


    pub fn get_owner(&self) -> &str {
        &self.owner
    }
    pub fn clear_owner(&mut self) {
        self.owner.clear();
    }

    // Param is passed by value, moved
    pub fn set_owner(&mut self, v: ::std::string::String) {
        self.owner = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_owner(&mut self) -> &mut ::std::string::String {
        &mut self.owner
    }

    // Take field
    pub fn take_owner(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.owner, ::std::string::String::new())
    }

    // int32 index = 4;


    pub fn get_index(&self) -> i32 {
        self.index
    }
    pub fn clear_index(&mut self) {
        self.index = 0;
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: i32) {
        self.index = v;
    }

    // int32 rank = 5;


    pub fn get_rank(&self) -> i32 {
        self.rank
    }
    pub fn clear_rank(&mut self) {
        self.rank = 0;
    }

    // Param is passed by value, moved
    pub fn set_rank(&mut self, v: i32) {
        self.rank = v;
    }
}

impl ::protobuf::Message for ProcessId {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.host)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.port = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.owner)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.index = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.rank = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.host.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.host);
        }
        if self.port != 0 {
            my_size += ::protobuf::rt::value_size(2, self.port, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.owner.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.owner);
        }
        if self.index != 0 {
            my_size += ::protobuf::rt::value_size(4, self.index, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.rank != 0 {
            my_size += ::protobuf::rt::value_size(5, self.rank, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.host.is_empty() {
            os.write_string(1, &self.host)?;
        }
        if self.port != 0 {
            os.write_int32(2, self.port)?;
        }
        if !self.owner.is_empty() {
            os.write_string(3, &self.owner)?;
        }
        if self.index != 0 {
            os.write_int32(4, self.index)?;
        }
        if self.rank != 0 {
            os.write_int32(5, self.rank)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ProcessId {
        ProcessId::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "host",
                    |m: &ProcessId| { &m.host },
                    |m: &mut ProcessId| { &mut m.host },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "port",
                    |m: &ProcessId| { &m.port },
                    |m: &mut ProcessId| { &mut m.port },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "owner",
                    |m: &ProcessId| { &m.owner },
                    |m: &mut ProcessId| { &mut m.owner },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "index",
                    |m: &ProcessId| { &m.index },
                    |m: &mut ProcessId| { &mut m.index },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "rank",
                    |m: &ProcessId| { &m.rank },
                    |m: &mut ProcessId| { &mut m.rank },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ProcessId>(
                    "ProcessId",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ProcessId {
        static mut instance: ::protobuf::lazy::Lazy<ProcessId> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(ProcessId::new)
        }
    }
}

impl ::protobuf::Clear for ProcessId {
    fn clear(&mut self) {
        self.host.clear();
        self.port = 0;
        self.owner.clear();
        self.index = 0;
        self.rank = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ProcessId {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProcessId {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UcPropose {
    // message fields
    pub value: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UcPropose {
    fn default() -> &'a UcPropose {
        <UcPropose as ::protobuf::Message>::default_instance()
    }
}

impl UcPropose {
    pub fn new() -> UcPropose {
        ::std::default::Default::default()
    }

    // int32 value = 1;


    pub fn get_value(&self) -> i32 {
        self.value
    }
    pub fn clear_value(&mut self) {
        self.value = 0;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: i32) {
        self.value = v;
    }
}

impl ::protobuf::Message for UcPropose {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.value = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != 0 {
            my_size += ::protobuf::rt::value_size(1, self.value, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.value != 0 {
            os.write_int32(1, self.value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UcPropose {
        UcPropose::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "value",
                    |m: &UcPropose| { &m.value },
                    |m: &mut UcPropose| { &mut m.value },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<UcPropose>(
                    "UcPropose",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static UcPropose {
        static mut instance: ::protobuf::lazy::Lazy<UcPropose> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(UcPropose::new)
        }
    }
}

impl ::protobuf::Clear for UcPropose {
    fn clear(&mut self) {
        self.value = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UcPropose {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UcPropose {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EcStartEpoch {
    // message fields
    pub newTimestamp: i32,
    pub newLeader: ::protobuf::SingularPtrField<ProcessId>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EcStartEpoch {
    fn default() -> &'a EcStartEpoch {
        <EcStartEpoch as ::protobuf::Message>::default_instance()
    }
}

impl EcStartEpoch {
    pub fn new() -> EcStartEpoch {
        ::std::default::Default::default()
    }

    // int32 newTimestamp = 1;


    pub fn get_newTimestamp(&self) -> i32 {
        self.newTimestamp
    }
    pub fn clear_newTimestamp(&mut self) {
        self.newTimestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_newTimestamp(&mut self, v: i32) {
        self.newTimestamp = v;
    }

    // .ProcessId newLeader = 2;


    pub fn get_newLeader(&self) -> &ProcessId {
        self.newLeader.as_ref().unwrap_or_else(|| ProcessId::default_instance())
    }
    pub fn clear_newLeader(&mut self) {
        self.newLeader.clear();
    }

    pub fn has_newLeader(&self) -> bool {
        self.newLeader.is_some()
    }

    // Param is passed by value, moved
    pub fn set_newLeader(&mut self, v: ProcessId) {
        self.newLeader = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_newLeader(&mut self) -> &mut ProcessId {
        if self.newLeader.is_none() {
            self.newLeader.set_default();
        }
        self.newLeader.as_mut().unwrap()
    }

    // Take field
    pub fn take_newLeader(&mut self) -> ProcessId {
        self.newLeader.take().unwrap_or_else(|| ProcessId::new())
    }
}

impl ::protobuf::Message for EcStartEpoch {
    fn is_initialized(&self) -> bool {
        for v in &self.newLeader {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.newTimestamp = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.newLeader)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.newTimestamp != 0 {
            my_size += ::protobuf::rt::value_size(1, self.newTimestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.newLeader.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.newTimestamp != 0 {
            os.write_int32(1, self.newTimestamp)?;
        }
        if let Some(ref v) = self.newLeader.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EcStartEpoch {
        EcStartEpoch::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "newTimestamp",
                    |m: &EcStartEpoch| { &m.newTimestamp },
                    |m: &mut EcStartEpoch| { &mut m.newTimestamp },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ProcessId>>(
                    "newLeader",
                    |m: &EcStartEpoch| { &m.newLeader },
                    |m: &mut EcStartEpoch| { &mut m.newLeader },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<EcStartEpoch>(
                    "EcStartEpoch",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static EcStartEpoch {
        static mut instance: ::protobuf::lazy::Lazy<EcStartEpoch> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(EcStartEpoch::new)
        }
    }
}

impl ::protobuf::Clear for EcStartEpoch {
    fn clear(&mut self) {
        self.newTimestamp = 0;
        self.newLeader.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EcStartEpoch {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EcStartEpoch {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EpAbort {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EpAbort {
    fn default() -> &'a EpAbort {
        <EpAbort as ::protobuf::Message>::default_instance()
    }
}

impl EpAbort {
    pub fn new() -> EpAbort {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for EpAbort {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EpAbort {
        EpAbort::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<EpAbort>(
                    "EpAbort",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static EpAbort {
        static mut instance: ::protobuf::lazy::Lazy<EpAbort> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(EpAbort::new)
        }
    }
}

impl ::protobuf::Clear for EpAbort {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EpAbort {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EpAbort {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EpInit {
    // message fields
    pub valueTimestamp: i32,
    pub value: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EpInit {
    fn default() -> &'a EpInit {
        <EpInit as ::protobuf::Message>::default_instance()
    }
}

impl EpInit {
    pub fn new() -> EpInit {
        ::std::default::Default::default()
    }

    // int32 valueTimestamp = 1;


    pub fn get_valueTimestamp(&self) -> i32 {
        self.valueTimestamp
    }
    pub fn clear_valueTimestamp(&mut self) {
        self.valueTimestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_valueTimestamp(&mut self, v: i32) {
        self.valueTimestamp = v;
    }

    // int32 value = 2;


    pub fn get_value(&self) -> i32 {
        self.value
    }
    pub fn clear_value(&mut self) {
        self.value = 0;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: i32) {
        self.value = v;
    }
}

impl ::protobuf::Message for EpInit {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.valueTimestamp = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.value = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.valueTimestamp != 0 {
            my_size += ::protobuf::rt::value_size(1, self.valueTimestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.value != 0 {
            my_size += ::protobuf::rt::value_size(2, self.value, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.valueTimestamp != 0 {
            os.write_int32(1, self.valueTimestamp)?;
        }
        if self.value != 0 {
            os.write_int32(2, self.value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EpInit {
        EpInit::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "valueTimestamp",
                    |m: &EpInit| { &m.valueTimestamp },
                    |m: &mut EpInit| { &mut m.valueTimestamp },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "value",
                    |m: &EpInit| { &m.value },
                    |m: &mut EpInit| { &mut m.value },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<EpInit>(
                    "EpInit",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static EpInit {
        static mut instance: ::protobuf::lazy::Lazy<EpInit> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(EpInit::new)
        }
    }
}

impl ::protobuf::Clear for EpInit {
    fn clear(&mut self) {
        self.valueTimestamp = 0;
        self.value = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EpInit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EpInit {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EpAborted {
    // message fields
    pub valueTimestamp: i32,
    pub value: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EpAborted {
    fn default() -> &'a EpAborted {
        <EpAborted as ::protobuf::Message>::default_instance()
    }
}

impl EpAborted {
    pub fn new() -> EpAborted {
        ::std::default::Default::default()
    }

    // int32 valueTimestamp = 1;


    pub fn get_valueTimestamp(&self) -> i32 {
        self.valueTimestamp
    }
    pub fn clear_valueTimestamp(&mut self) {
        self.valueTimestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_valueTimestamp(&mut self, v: i32) {
        self.valueTimestamp = v;
    }

    // int32 value = 2;


    pub fn get_value(&self) -> i32 {
        self.value
    }
    pub fn clear_value(&mut self) {
        self.value = 0;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: i32) {
        self.value = v;
    }
}

impl ::protobuf::Message for EpAborted {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.valueTimestamp = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.value = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.valueTimestamp != 0 {
            my_size += ::protobuf::rt::value_size(1, self.valueTimestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.value != 0 {
            my_size += ::protobuf::rt::value_size(2, self.value, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.valueTimestamp != 0 {
            os.write_int32(1, self.valueTimestamp)?;
        }
        if self.value != 0 {
            os.write_int32(2, self.value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EpAborted {
        EpAborted::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "valueTimestamp",
                    |m: &EpAborted| { &m.valueTimestamp },
                    |m: &mut EpAborted| { &mut m.valueTimestamp },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "value",
                    |m: &EpAborted| { &m.value },
                    |m: &mut EpAborted| { &mut m.value },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<EpAborted>(
                    "EpAborted",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static EpAborted {
        static mut instance: ::protobuf::lazy::Lazy<EpAborted> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(EpAborted::new)
        }
    }
}

impl ::protobuf::Clear for EpAborted {
    fn clear(&mut self) {
        self.valueTimestamp = 0;
        self.value = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EpAborted {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EpAborted {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EpPropose {
    // message fields
    pub value: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EpPropose {
    fn default() -> &'a EpPropose {
        <EpPropose as ::protobuf::Message>::default_instance()
    }
}

impl EpPropose {
    pub fn new() -> EpPropose {
        ::std::default::Default::default()
    }

    // int32 value = 1;


    pub fn get_value(&self) -> i32 {
        self.value
    }
    pub fn clear_value(&mut self) {
        self.value = 0;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: i32) {
        self.value = v;
    }
}

impl ::protobuf::Message for EpPropose {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.value = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != 0 {
            my_size += ::protobuf::rt::value_size(1, self.value, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.value != 0 {
            os.write_int32(1, self.value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EpPropose {
        EpPropose::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "value",
                    |m: &EpPropose| { &m.value },
                    |m: &mut EpPropose| { &mut m.value },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<EpPropose>(
                    "EpPropose",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static EpPropose {
        static mut instance: ::protobuf::lazy::Lazy<EpPropose> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(EpPropose::new)
        }
    }
}

impl ::protobuf::Clear for EpPropose {
    fn clear(&mut self) {
        self.value = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EpPropose {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EpPropose {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EpDecide {
    // message fields
    pub value: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EpDecide {
    fn default() -> &'a EpDecide {
        <EpDecide as ::protobuf::Message>::default_instance()
    }
}

impl EpDecide {
    pub fn new() -> EpDecide {
        ::std::default::Default::default()
    }

    // int32 value = 1;


    pub fn get_value(&self) -> i32 {
        self.value
    }
    pub fn clear_value(&mut self) {
        self.value = 0;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: i32) {
        self.value = v;
    }
}

impl ::protobuf::Message for EpDecide {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.value = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != 0 {
            my_size += ::protobuf::rt::value_size(1, self.value, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.value != 0 {
            os.write_int32(1, self.value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EpDecide {
        EpDecide::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "value",
                    |m: &EpDecide| { &m.value },
                    |m: &mut EpDecide| { &mut m.value },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<EpDecide>(
                    "EpDecide",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static EpDecide {
        static mut instance: ::protobuf::lazy::Lazy<EpDecide> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(EpDecide::new)
        }
    }
}

impl ::protobuf::Clear for EpDecide {
    fn clear(&mut self) {
        self.value = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EpDecide {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EpDecide {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UcDecide {
    // message fields
    pub value: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UcDecide {
    fn default() -> &'a UcDecide {
        <UcDecide as ::protobuf::Message>::default_instance()
    }
}

impl UcDecide {
    pub fn new() -> UcDecide {
        ::std::default::Default::default()
    }

    // int32 value = 1;


    pub fn get_value(&self) -> i32 {
        self.value
    }
    pub fn clear_value(&mut self) {
        self.value = 0;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: i32) {
        self.value = v;
    }
}

impl ::protobuf::Message for UcDecide {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.value = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != 0 {
            my_size += ::protobuf::rt::value_size(1, self.value, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.value != 0 {
            os.write_int32(1, self.value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UcDecide {
        UcDecide::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "value",
                    |m: &UcDecide| { &m.value },
                    |m: &mut UcDecide| { &mut m.value },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<UcDecide>(
                    "UcDecide",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static UcDecide {
        static mut instance: ::protobuf::lazy::Lazy<UcDecide> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(UcDecide::new)
        }
    }
}

impl ::protobuf::Clear for UcDecide {
    fn clear(&mut self) {
        self.value = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UcDecide {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UcDecide {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EpRead_ {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EpRead_ {
    fn default() -> &'a EpRead_ {
        <EpRead_ as ::protobuf::Message>::default_instance()
    }
}

impl EpRead_ {
    pub fn new() -> EpRead_ {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for EpRead_ {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EpRead_ {
        EpRead_::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<EpRead_>(
                    "EpRead_",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static EpRead_ {
        static mut instance: ::protobuf::lazy::Lazy<EpRead_> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(EpRead_::new)
        }
    }
}

impl ::protobuf::Clear for EpRead_ {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EpRead_ {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EpRead_ {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EpState_ {
    // message fields
    pub valueTimestamp: i32,
    pub value: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EpState_ {
    fn default() -> &'a EpState_ {
        <EpState_ as ::protobuf::Message>::default_instance()
    }
}

impl EpState_ {
    pub fn new() -> EpState_ {
        ::std::default::Default::default()
    }

    // int32 valueTimestamp = 1;


    pub fn get_valueTimestamp(&self) -> i32 {
        self.valueTimestamp
    }
    pub fn clear_valueTimestamp(&mut self) {
        self.valueTimestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_valueTimestamp(&mut self, v: i32) {
        self.valueTimestamp = v;
    }

    // int32 value = 2;


    pub fn get_value(&self) -> i32 {
        self.value
    }
    pub fn clear_value(&mut self) {
        self.value = 0;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: i32) {
        self.value = v;
    }
}

impl ::protobuf::Message for EpState_ {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.valueTimestamp = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.value = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.valueTimestamp != 0 {
            my_size += ::protobuf::rt::value_size(1, self.valueTimestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.value != 0 {
            my_size += ::protobuf::rt::value_size(2, self.value, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.valueTimestamp != 0 {
            os.write_int32(1, self.valueTimestamp)?;
        }
        if self.value != 0 {
            os.write_int32(2, self.value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EpState_ {
        EpState_::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "valueTimestamp",
                    |m: &EpState_| { &m.valueTimestamp },
                    |m: &mut EpState_| { &mut m.valueTimestamp },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "value",
                    |m: &EpState_| { &m.value },
                    |m: &mut EpState_| { &mut m.value },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<EpState_>(
                    "EpState_",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static EpState_ {
        static mut instance: ::protobuf::lazy::Lazy<EpState_> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(EpState_::new)
        }
    }
}

impl ::protobuf::Clear for EpState_ {
    fn clear(&mut self) {
        self.valueTimestamp = 0;
        self.value = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EpState_ {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EpState_ {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EpWrite_ {
    // message fields
    pub value: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EpWrite_ {
    fn default() -> &'a EpWrite_ {
        <EpWrite_ as ::protobuf::Message>::default_instance()
    }
}

impl EpWrite_ {
    pub fn new() -> EpWrite_ {
        ::std::default::Default::default()
    }

    // int32 value = 1;


    pub fn get_value(&self) -> i32 {
        self.value
    }
    pub fn clear_value(&mut self) {
        self.value = 0;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: i32) {
        self.value = v;
    }
}

impl ::protobuf::Message for EpWrite_ {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.value = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != 0 {
            my_size += ::protobuf::rt::value_size(1, self.value, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.value != 0 {
            os.write_int32(1, self.value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EpWrite_ {
        EpWrite_::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "value",
                    |m: &EpWrite_| { &m.value },
                    |m: &mut EpWrite_| { &mut m.value },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<EpWrite_>(
                    "EpWrite_",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static EpWrite_ {
        static mut instance: ::protobuf::lazy::Lazy<EpWrite_> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(EpWrite_::new)
        }
    }
}

impl ::protobuf::Clear for EpWrite_ {
    fn clear(&mut self) {
        self.value = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EpWrite_ {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EpWrite_ {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EpAccept_ {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EpAccept_ {
    fn default() -> &'a EpAccept_ {
        <EpAccept_ as ::protobuf::Message>::default_instance()
    }
}

impl EpAccept_ {
    pub fn new() -> EpAccept_ {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for EpAccept_ {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EpAccept_ {
        EpAccept_::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<EpAccept_>(
                    "EpAccept_",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static EpAccept_ {
        static mut instance: ::protobuf::lazy::Lazy<EpAccept_> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(EpAccept_::new)
        }
    }
}

impl ::protobuf::Clear for EpAccept_ {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EpAccept_ {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EpAccept_ {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EpDecided_ {
    // message fields
    pub value: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EpDecided_ {
    fn default() -> &'a EpDecided_ {
        <EpDecided_ as ::protobuf::Message>::default_instance()
    }
}

impl EpDecided_ {
    pub fn new() -> EpDecided_ {
        ::std::default::Default::default()
    }

    // int32 value = 1;


    pub fn get_value(&self) -> i32 {
        self.value
    }
    pub fn clear_value(&mut self) {
        self.value = 0;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: i32) {
        self.value = v;
    }
}

impl ::protobuf::Message for EpDecided_ {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.value = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != 0 {
            my_size += ::protobuf::rt::value_size(1, self.value, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.value != 0 {
            os.write_int32(1, self.value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EpDecided_ {
        EpDecided_::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "value",
                    |m: &EpDecided_| { &m.value },
                    |m: &mut EpDecided_| { &mut m.value },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<EpDecided_>(
                    "EpDecided_",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static EpDecided_ {
        static mut instance: ::protobuf::lazy::Lazy<EpDecided_> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(EpDecided_::new)
        }
    }
}

impl ::protobuf::Clear for EpDecided_ {
    fn clear(&mut self) {
        self.value = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EpDecided_ {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EpDecided_ {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EcNewEpoch_ {
    // message fields
    pub timestamp: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EcNewEpoch_ {
    fn default() -> &'a EcNewEpoch_ {
        <EcNewEpoch_ as ::protobuf::Message>::default_instance()
    }
}

impl EcNewEpoch_ {
    pub fn new() -> EcNewEpoch_ {
        ::std::default::Default::default()
    }

    // int32 timestamp = 1;


    pub fn get_timestamp(&self) -> i32 {
        self.timestamp
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: i32) {
        self.timestamp = v;
    }
}

impl ::protobuf::Message for EcNewEpoch_ {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.timestamp = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::value_size(1, self.timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.timestamp != 0 {
            os.write_int32(1, self.timestamp)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EcNewEpoch_ {
        EcNewEpoch_::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "timestamp",
                    |m: &EcNewEpoch_| { &m.timestamp },
                    |m: &mut EcNewEpoch_| { &mut m.timestamp },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<EcNewEpoch_>(
                    "EcNewEpoch_",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static EcNewEpoch_ {
        static mut instance: ::protobuf::lazy::Lazy<EcNewEpoch_> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(EcNewEpoch_::new)
        }
    }
}

impl ::protobuf::Clear for EcNewEpoch_ {
    fn clear(&mut self) {
        self.timestamp = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EcNewEpoch_ {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EcNewEpoch_ {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EcNack_ {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EcNack_ {
    fn default() -> &'a EcNack_ {
        <EcNack_ as ::protobuf::Message>::default_instance()
    }
}

impl EcNack_ {
    pub fn new() -> EcNack_ {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for EcNack_ {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EcNack_ {
        EcNack_::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<EcNack_>(
                    "EcNack_",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static EcNack_ {
        static mut instance: ::protobuf::lazy::Lazy<EcNack_> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(EcNack_::new)
        }
    }
}

impl ::protobuf::Clear for EcNack_ {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EcNack_ {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EcNack_ {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BebBroadcast {
    // message fields
    pub message: ::protobuf::SingularPtrField<Message>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BebBroadcast {
    fn default() -> &'a BebBroadcast {
        <BebBroadcast as ::protobuf::Message>::default_instance()
    }
}

impl BebBroadcast {
    pub fn new() -> BebBroadcast {
        ::std::default::Default::default()
    }

    // .Message message = 1;


    pub fn get_message(&self) -> &Message {
        self.message.as_ref().unwrap_or_else(|| Message::default_instance())
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: Message) {
        self.message = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut Message {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> Message {
        self.message.take().unwrap_or_else(|| Message::new())
    }
}

impl ::protobuf::Message for BebBroadcast {
    fn is_initialized(&self) -> bool {
        for v in &self.message {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.message.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.message.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BebBroadcast {
        BebBroadcast::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Message>>(
                    "message",
                    |m: &BebBroadcast| { &m.message },
                    |m: &mut BebBroadcast| { &mut m.message },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<BebBroadcast>(
                    "BebBroadcast",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static BebBroadcast {
        static mut instance: ::protobuf::lazy::Lazy<BebBroadcast> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(BebBroadcast::new)
        }
    }
}

impl ::protobuf::Clear for BebBroadcast {
    fn clear(&mut self) {
        self.message.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BebBroadcast {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BebBroadcast {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BebDeliver {
    // message fields
    pub message: ::protobuf::SingularPtrField<Message>,
    pub sender: ::protobuf::SingularPtrField<ProcessId>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BebDeliver {
    fn default() -> &'a BebDeliver {
        <BebDeliver as ::protobuf::Message>::default_instance()
    }
}

impl BebDeliver {
    pub fn new() -> BebDeliver {
        ::std::default::Default::default()
    }

    // .Message message = 1;


    pub fn get_message(&self) -> &Message {
        self.message.as_ref().unwrap_or_else(|| Message::default_instance())
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: Message) {
        self.message = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut Message {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> Message {
        self.message.take().unwrap_or_else(|| Message::new())
    }

    // .ProcessId sender = 2;


    pub fn get_sender(&self) -> &ProcessId {
        self.sender.as_ref().unwrap_or_else(|| ProcessId::default_instance())
    }
    pub fn clear_sender(&mut self) {
        self.sender.clear();
    }

    pub fn has_sender(&self) -> bool {
        self.sender.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sender(&mut self, v: ProcessId) {
        self.sender = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sender(&mut self) -> &mut ProcessId {
        if self.sender.is_none() {
            self.sender.set_default();
        }
        self.sender.as_mut().unwrap()
    }

    // Take field
    pub fn take_sender(&mut self) -> ProcessId {
        self.sender.take().unwrap_or_else(|| ProcessId::new())
    }
}

impl ::protobuf::Message for BebDeliver {
    fn is_initialized(&self) -> bool {
        for v in &self.message {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.sender {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.message)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.sender)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.message.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.sender.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.message.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.sender.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BebDeliver {
        BebDeliver::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Message>>(
                    "message",
                    |m: &BebDeliver| { &m.message },
                    |m: &mut BebDeliver| { &mut m.message },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ProcessId>>(
                    "sender",
                    |m: &BebDeliver| { &m.sender },
                    |m: &mut BebDeliver| { &mut m.sender },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<BebDeliver>(
                    "BebDeliver",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static BebDeliver {
        static mut instance: ::protobuf::lazy::Lazy<BebDeliver> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(BebDeliver::new)
        }
    }
}

impl ::protobuf::Clear for BebDeliver {
    fn clear(&mut self) {
        self.message.clear();
        self.sender.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BebDeliver {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BebDeliver {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EldRecovery {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EldRecovery {
    fn default() -> &'a EldRecovery {
        <EldRecovery as ::protobuf::Message>::default_instance()
    }
}

impl EldRecovery {
    pub fn new() -> EldRecovery {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for EldRecovery {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EldRecovery {
        EldRecovery::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<EldRecovery>(
                    "EldRecovery",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static EldRecovery {
        static mut instance: ::protobuf::lazy::Lazy<EldRecovery> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(EldRecovery::new)
        }
    }
}

impl ::protobuf::Clear for EldRecovery {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EldRecovery {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EldRecovery {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EldTimeout {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EldTimeout {
    fn default() -> &'a EldTimeout {
        <EldTimeout as ::protobuf::Message>::default_instance()
    }
}

impl EldTimeout {
    pub fn new() -> EldTimeout {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for EldTimeout {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EldTimeout {
        EldTimeout::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<EldTimeout>(
                    "EldTimeout",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static EldTimeout {
        static mut instance: ::protobuf::lazy::Lazy<EldTimeout> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(EldTimeout::new)
        }
    }
}

impl ::protobuf::Clear for EldTimeout {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EldTimeout {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EldTimeout {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EldTrust {
    // message fields
    pub processId: ::protobuf::SingularPtrField<ProcessId>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EldTrust {
    fn default() -> &'a EldTrust {
        <EldTrust as ::protobuf::Message>::default_instance()
    }
}

impl EldTrust {
    pub fn new() -> EldTrust {
        ::std::default::Default::default()
    }

    // .ProcessId processId = 1;


    pub fn get_processId(&self) -> &ProcessId {
        self.processId.as_ref().unwrap_or_else(|| ProcessId::default_instance())
    }
    pub fn clear_processId(&mut self) {
        self.processId.clear();
    }

    pub fn has_processId(&self) -> bool {
        self.processId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_processId(&mut self, v: ProcessId) {
        self.processId = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_processId(&mut self) -> &mut ProcessId {
        if self.processId.is_none() {
            self.processId.set_default();
        }
        self.processId.as_mut().unwrap()
    }

    // Take field
    pub fn take_processId(&mut self) -> ProcessId {
        self.processId.take().unwrap_or_else(|| ProcessId::new())
    }
}

impl ::protobuf::Message for EldTrust {
    fn is_initialized(&self) -> bool {
        for v in &self.processId {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.processId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.processId.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.processId.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EldTrust {
        EldTrust::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ProcessId>>(
                    "processId",
                    |m: &EldTrust| { &m.processId },
                    |m: &mut EldTrust| { &mut m.processId },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<EldTrust>(
                    "EldTrust",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static EldTrust {
        static mut instance: ::protobuf::lazy::Lazy<EldTrust> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(EldTrust::new)
        }
    }
}

impl ::protobuf::Clear for EldTrust {
    fn clear(&mut self) {
        self.processId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EldTrust {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EldTrust {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EldHeartbeat_ {
    // message fields
    pub epoch: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EldHeartbeat_ {
    fn default() -> &'a EldHeartbeat_ {
        <EldHeartbeat_ as ::protobuf::Message>::default_instance()
    }
}

impl EldHeartbeat_ {
    pub fn new() -> EldHeartbeat_ {
        ::std::default::Default::default()
    }

    // int32 epoch = 1;


    pub fn get_epoch(&self) -> i32 {
        self.epoch
    }
    pub fn clear_epoch(&mut self) {
        self.epoch = 0;
    }

    // Param is passed by value, moved
    pub fn set_epoch(&mut self, v: i32) {
        self.epoch = v;
    }
}

impl ::protobuf::Message for EldHeartbeat_ {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.epoch = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.epoch != 0 {
            my_size += ::protobuf::rt::value_size(1, self.epoch, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.epoch != 0 {
            os.write_int32(1, self.epoch)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EldHeartbeat_ {
        EldHeartbeat_::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "epoch",
                    |m: &EldHeartbeat_| { &m.epoch },
                    |m: &mut EldHeartbeat_| { &mut m.epoch },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<EldHeartbeat_>(
                    "EldHeartbeat_",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static EldHeartbeat_ {
        static mut instance: ::protobuf::lazy::Lazy<EldHeartbeat_> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(EldHeartbeat_::new)
        }
    }
}

impl ::protobuf::Clear for EldHeartbeat_ {
    fn clear(&mut self) {
        self.epoch = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EldHeartbeat_ {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EldHeartbeat_ {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PlSend {
    // message fields
    pub message: ::protobuf::SingularPtrField<Message>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PlSend {
    fn default() -> &'a PlSend {
        <PlSend as ::protobuf::Message>::default_instance()
    }
}

impl PlSend {
    pub fn new() -> PlSend {
        ::std::default::Default::default()
    }

    // .Message message = 1;


    pub fn get_message(&self) -> &Message {
        self.message.as_ref().unwrap_or_else(|| Message::default_instance())
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: Message) {
        self.message = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut Message {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> Message {
        self.message.take().unwrap_or_else(|| Message::new())
    }
}

impl ::protobuf::Message for PlSend {
    fn is_initialized(&self) -> bool {
        for v in &self.message {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.message.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.message.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PlSend {
        PlSend::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Message>>(
                    "message",
                    |m: &PlSend| { &m.message },
                    |m: &mut PlSend| { &mut m.message },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PlSend>(
                    "PlSend",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PlSend {
        static mut instance: ::protobuf::lazy::Lazy<PlSend> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(PlSend::new)
        }
    }
}

impl ::protobuf::Clear for PlSend {
    fn clear(&mut self) {
        self.message.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PlSend {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PlSend {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PlDeliver {
    // message fields
    pub message: ::protobuf::SingularPtrField<Message>,
    pub sender: ::protobuf::SingularPtrField<ProcessId>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PlDeliver {
    fn default() -> &'a PlDeliver {
        <PlDeliver as ::protobuf::Message>::default_instance()
    }
}

impl PlDeliver {
    pub fn new() -> PlDeliver {
        ::std::default::Default::default()
    }

    // .Message message = 1;


    pub fn get_message(&self) -> &Message {
        self.message.as_ref().unwrap_or_else(|| Message::default_instance())
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: Message) {
        self.message = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut Message {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> Message {
        self.message.take().unwrap_or_else(|| Message::new())
    }

    // .ProcessId sender = 2;


    pub fn get_sender(&self) -> &ProcessId {
        self.sender.as_ref().unwrap_or_else(|| ProcessId::default_instance())
    }
    pub fn clear_sender(&mut self) {
        self.sender.clear();
    }

    pub fn has_sender(&self) -> bool {
        self.sender.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sender(&mut self, v: ProcessId) {
        self.sender = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sender(&mut self) -> &mut ProcessId {
        if self.sender.is_none() {
            self.sender.set_default();
        }
        self.sender.as_mut().unwrap()
    }

    // Take field
    pub fn take_sender(&mut self) -> ProcessId {
        self.sender.take().unwrap_or_else(|| ProcessId::new())
    }
}

impl ::protobuf::Message for PlDeliver {
    fn is_initialized(&self) -> bool {
        for v in &self.message {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.sender {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.message)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.sender)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.message.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.sender.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.message.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.sender.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PlDeliver {
        PlDeliver::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Message>>(
                    "message",
                    |m: &PlDeliver| { &m.message },
                    |m: &mut PlDeliver| { &mut m.message },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ProcessId>>(
                    "sender",
                    |m: &PlDeliver| { &m.sender },
                    |m: &mut PlDeliver| { &mut m.sender },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PlDeliver>(
                    "PlDeliver",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PlDeliver {
        static mut instance: ::protobuf::lazy::Lazy<PlDeliver> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(PlDeliver::new)
        }
    }
}

impl ::protobuf::Clear for PlDeliver {
    fn clear(&mut self) {
        self.message.clear();
        self.sender.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PlDeliver {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PlDeliver {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AppRegistration {
    // message fields
    pub owner: ::std::string::String,
    pub index: i32,
    pub port: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AppRegistration {
    fn default() -> &'a AppRegistration {
        <AppRegistration as ::protobuf::Message>::default_instance()
    }
}

impl AppRegistration {
    pub fn new() -> AppRegistration {
        ::std::default::Default::default()
    }

    // string owner = 1;


    pub fn get_owner(&self) -> &str {
        &self.owner
    }
    pub fn clear_owner(&mut self) {
        self.owner.clear();
    }

    // Param is passed by value, moved
    pub fn set_owner(&mut self, v: ::std::string::String) {
        self.owner = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_owner(&mut self) -> &mut ::std::string::String {
        &mut self.owner
    }

    // Take field
    pub fn take_owner(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.owner, ::std::string::String::new())
    }

    // int32 index = 2;


    pub fn get_index(&self) -> i32 {
        self.index
    }
    pub fn clear_index(&mut self) {
        self.index = 0;
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: i32) {
        self.index = v;
    }

    // int32 port = 3;


    pub fn get_port(&self) -> i32 {
        self.port
    }
    pub fn clear_port(&mut self) {
        self.port = 0;
    }

    // Param is passed by value, moved
    pub fn set_port(&mut self, v: i32) {
        self.port = v;
    }
}

impl ::protobuf::Message for AppRegistration {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.owner)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.index = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.port = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.owner.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.owner);
        }
        if self.index != 0 {
            my_size += ::protobuf::rt::value_size(2, self.index, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.port != 0 {
            my_size += ::protobuf::rt::value_size(3, self.port, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.owner.is_empty() {
            os.write_string(1, &self.owner)?;
        }
        if self.index != 0 {
            os.write_int32(2, self.index)?;
        }
        if self.port != 0 {
            os.write_int32(3, self.port)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AppRegistration {
        AppRegistration::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "owner",
                    |m: &AppRegistration| { &m.owner },
                    |m: &mut AppRegistration| { &mut m.owner },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "index",
                    |m: &AppRegistration| { &m.index },
                    |m: &mut AppRegistration| { &mut m.index },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "port",
                    |m: &AppRegistration| { &m.port },
                    |m: &mut AppRegistration| { &mut m.port },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AppRegistration>(
                    "AppRegistration",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AppRegistration {
        static mut instance: ::protobuf::lazy::Lazy<AppRegistration> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(AppRegistration::new)
        }
    }
}

impl ::protobuf::Clear for AppRegistration {
    fn clear(&mut self) {
        self.owner.clear();
        self.index = 0;
        self.port = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AppRegistration {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AppRegistration {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AppPropose {
    // message fields
    pub value: i32,
    pub processes: ::protobuf::RepeatedField<ProcessId>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AppPropose {
    fn default() -> &'a AppPropose {
        <AppPropose as ::protobuf::Message>::default_instance()
    }
}

impl AppPropose {
    pub fn new() -> AppPropose {
        ::std::default::Default::default()
    }

    // int32 value = 1;


    pub fn get_value(&self) -> i32 {
        self.value
    }
    pub fn clear_value(&mut self) {
        self.value = 0;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: i32) {
        self.value = v;
    }

    // repeated .ProcessId processes = 2;


    pub fn get_processes(&self) -> &[ProcessId] {
        &self.processes
    }
    pub fn clear_processes(&mut self) {
        self.processes.clear();
    }

    // Param is passed by value, moved
    pub fn set_processes(&mut self, v: ::protobuf::RepeatedField<ProcessId>) {
        self.processes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_processes(&mut self) -> &mut ::protobuf::RepeatedField<ProcessId> {
        &mut self.processes
    }

    // Take field
    pub fn take_processes(&mut self) -> ::protobuf::RepeatedField<ProcessId> {
        ::std::mem::replace(&mut self.processes, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for AppPropose {
    fn is_initialized(&self) -> bool {
        for v in &self.processes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.value = tmp;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.processes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != 0 {
            my_size += ::protobuf::rt::value_size(1, self.value, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.processes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.value != 0 {
            os.write_int32(1, self.value)?;
        }
        for v in &self.processes {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AppPropose {
        AppPropose::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "value",
                    |m: &AppPropose| { &m.value },
                    |m: &mut AppPropose| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ProcessId>>(
                    "processes",
                    |m: &AppPropose| { &m.processes },
                    |m: &mut AppPropose| { &mut m.processes },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AppPropose>(
                    "AppPropose",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AppPropose {
        static mut instance: ::protobuf::lazy::Lazy<AppPropose> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(AppPropose::new)
        }
    }
}

impl ::protobuf::Clear for AppPropose {
    fn clear(&mut self) {
        self.value = 0;
        self.processes.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AppPropose {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AppPropose {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AppDecide {
    // message fields
    pub value: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AppDecide {
    fn default() -> &'a AppDecide {
        <AppDecide as ::protobuf::Message>::default_instance()
    }
}

impl AppDecide {
    pub fn new() -> AppDecide {
        ::std::default::Default::default()
    }

    // int32 value = 1;


    pub fn get_value(&self) -> i32 {
        self.value
    }
    pub fn clear_value(&mut self) {
        self.value = 0;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: i32) {
        self.value = v;
    }
}

impl ::protobuf::Message for AppDecide {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.value = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != 0 {
            my_size += ::protobuf::rt::value_size(1, self.value, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.value != 0 {
            os.write_int32(1, self.value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AppDecide {
        AppDecide::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "value",
                    |m: &AppDecide| { &m.value },
                    |m: &mut AppDecide| { &mut m.value },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AppDecide>(
                    "AppDecide",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AppDecide {
        static mut instance: ::protobuf::lazy::Lazy<AppDecide> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(AppDecide::new)
        }
    }
}

impl ::protobuf::Clear for AppDecide {
    fn clear(&mut self) {
        self.value = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AppDecide {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AppDecide {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Message {
    // message fields
    pub field_type: Message_Type,
    pub messageUuid: ::std::string::String,
    pub abstractionId: ::std::string::String,
    pub systemId: ::std::string::String,
    pub appRegistration: ::protobuf::SingularPtrField<AppRegistration>,
    pub appPropose: ::protobuf::SingularPtrField<AppPropose>,
    pub appDecide: ::protobuf::SingularPtrField<AppDecide>,
    pub bebBroadcast: ::protobuf::SingularPtrField<BebBroadcast>,
    pub bebDeliver: ::protobuf::SingularPtrField<BebDeliver>,
    pub ecNack_: ::protobuf::SingularPtrField<EcNack_>,
    pub ecNewEpoch_: ::protobuf::SingularPtrField<EcNewEpoch_>,
    pub ecStartEpoch: ::protobuf::SingularPtrField<EcStartEpoch>,
    pub eldHeartbeat_: ::protobuf::SingularPtrField<EldHeartbeat_>,
    pub eldRecovery: ::protobuf::SingularPtrField<EldRecovery>,
    pub eldTimeout: ::protobuf::SingularPtrField<EldTimeout>,
    pub eldTrust: ::protobuf::SingularPtrField<EldTrust>,
    pub epAbort: ::protobuf::SingularPtrField<EpAbort>,
    pub epAborted: ::protobuf::SingularPtrField<EpAborted>,
    pub epAccept_: ::protobuf::SingularPtrField<EpAccept_>,
    pub epDecide: ::protobuf::SingularPtrField<EpDecide>,
    pub epDecided_: ::protobuf::SingularPtrField<EpDecided_>,
    pub epInit: ::protobuf::SingularPtrField<EpInit>,
    pub epPropose: ::protobuf::SingularPtrField<EpPropose>,
    pub epRead_: ::protobuf::SingularPtrField<EpRead_>,
    pub epState_: ::protobuf::SingularPtrField<EpState_>,
    pub epWrite_: ::protobuf::SingularPtrField<EpWrite_>,
    pub plDeliver: ::protobuf::SingularPtrField<PlDeliver>,
    pub plSend: ::protobuf::SingularPtrField<PlSend>,
    pub ucDecide: ::protobuf::SingularPtrField<UcDecide>,
    pub ucPropose: ::protobuf::SingularPtrField<UcPropose>,
    pub sender: ::protobuf::SingularPtrField<ProcessId>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Message {
    fn default() -> &'a Message {
        <Message as ::protobuf::Message>::default_instance()
    }
}

impl Message {
    pub fn new() -> Message {
        ::std::default::Default::default()
    }

    // .Message.Type type = 1;


    pub fn get_field_type(&self) -> Message_Type {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = Message_Type::NONE;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: Message_Type) {
        self.field_type = v;
    }

    // string messageUuid = 2;


    pub fn get_messageUuid(&self) -> &str {
        &self.messageUuid
    }
    pub fn clear_messageUuid(&mut self) {
        self.messageUuid.clear();
    }

    // Param is passed by value, moved
    pub fn set_messageUuid(&mut self, v: ::std::string::String) {
        self.messageUuid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_messageUuid(&mut self) -> &mut ::std::string::String {
        &mut self.messageUuid
    }

    // Take field
    pub fn take_messageUuid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.messageUuid, ::std::string::String::new())
    }

    // string abstractionId = 3;


    pub fn get_abstractionId(&self) -> &str {
        &self.abstractionId
    }
    pub fn clear_abstractionId(&mut self) {
        self.abstractionId.clear();
    }

    // Param is passed by value, moved
    pub fn set_abstractionId(&mut self, v: ::std::string::String) {
        self.abstractionId = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_abstractionId(&mut self) -> &mut ::std::string::String {
        &mut self.abstractionId
    }

    // Take field
    pub fn take_abstractionId(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.abstractionId, ::std::string::String::new())
    }

    // string systemId = 4;


    pub fn get_systemId(&self) -> &str {
        &self.systemId
    }
    pub fn clear_systemId(&mut self) {
        self.systemId.clear();
    }

    // Param is passed by value, moved
    pub fn set_systemId(&mut self, v: ::std::string::String) {
        self.systemId = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_systemId(&mut self) -> &mut ::std::string::String {
        &mut self.systemId
    }

    // Take field
    pub fn take_systemId(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.systemId, ::std::string::String::new())
    }

    // .AppRegistration appRegistration = 5;


    pub fn get_appRegistration(&self) -> &AppRegistration {
        self.appRegistration.as_ref().unwrap_or_else(|| AppRegistration::default_instance())
    }
    pub fn clear_appRegistration(&mut self) {
        self.appRegistration.clear();
    }

    pub fn has_appRegistration(&self) -> bool {
        self.appRegistration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appRegistration(&mut self, v: AppRegistration) {
        self.appRegistration = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_appRegistration(&mut self) -> &mut AppRegistration {
        if self.appRegistration.is_none() {
            self.appRegistration.set_default();
        }
        self.appRegistration.as_mut().unwrap()
    }

    // Take field
    pub fn take_appRegistration(&mut self) -> AppRegistration {
        self.appRegistration.take().unwrap_or_else(|| AppRegistration::new())
    }

    // .AppPropose appPropose = 6;


    pub fn get_appPropose(&self) -> &AppPropose {
        self.appPropose.as_ref().unwrap_or_else(|| AppPropose::default_instance())
    }
    pub fn clear_appPropose(&mut self) {
        self.appPropose.clear();
    }

    pub fn has_appPropose(&self) -> bool {
        self.appPropose.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appPropose(&mut self, v: AppPropose) {
        self.appPropose = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_appPropose(&mut self) -> &mut AppPropose {
        if self.appPropose.is_none() {
            self.appPropose.set_default();
        }
        self.appPropose.as_mut().unwrap()
    }

    // Take field
    pub fn take_appPropose(&mut self) -> AppPropose {
        self.appPropose.take().unwrap_or_else(|| AppPropose::new())
    }

    // .AppDecide appDecide = 7;


    pub fn get_appDecide(&self) -> &AppDecide {
        self.appDecide.as_ref().unwrap_or_else(|| AppDecide::default_instance())
    }
    pub fn clear_appDecide(&mut self) {
        self.appDecide.clear();
    }

    pub fn has_appDecide(&self) -> bool {
        self.appDecide.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appDecide(&mut self, v: AppDecide) {
        self.appDecide = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_appDecide(&mut self) -> &mut AppDecide {
        if self.appDecide.is_none() {
            self.appDecide.set_default();
        }
        self.appDecide.as_mut().unwrap()
    }

    // Take field
    pub fn take_appDecide(&mut self) -> AppDecide {
        self.appDecide.take().unwrap_or_else(|| AppDecide::new())
    }

    // .BebBroadcast bebBroadcast = 10;


    pub fn get_bebBroadcast(&self) -> &BebBroadcast {
        self.bebBroadcast.as_ref().unwrap_or_else(|| BebBroadcast::default_instance())
    }
    pub fn clear_bebBroadcast(&mut self) {
        self.bebBroadcast.clear();
    }

    pub fn has_bebBroadcast(&self) -> bool {
        self.bebBroadcast.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bebBroadcast(&mut self, v: BebBroadcast) {
        self.bebBroadcast = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bebBroadcast(&mut self) -> &mut BebBroadcast {
        if self.bebBroadcast.is_none() {
            self.bebBroadcast.set_default();
        }
        self.bebBroadcast.as_mut().unwrap()
    }

    // Take field
    pub fn take_bebBroadcast(&mut self) -> BebBroadcast {
        self.bebBroadcast.take().unwrap_or_else(|| BebBroadcast::new())
    }

    // .BebDeliver bebDeliver = 11;


    pub fn get_bebDeliver(&self) -> &BebDeliver {
        self.bebDeliver.as_ref().unwrap_or_else(|| BebDeliver::default_instance())
    }
    pub fn clear_bebDeliver(&mut self) {
        self.bebDeliver.clear();
    }

    pub fn has_bebDeliver(&self) -> bool {
        self.bebDeliver.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bebDeliver(&mut self, v: BebDeliver) {
        self.bebDeliver = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bebDeliver(&mut self) -> &mut BebDeliver {
        if self.bebDeliver.is_none() {
            self.bebDeliver.set_default();
        }
        self.bebDeliver.as_mut().unwrap()
    }

    // Take field
    pub fn take_bebDeliver(&mut self) -> BebDeliver {
        self.bebDeliver.take().unwrap_or_else(|| BebDeliver::new())
    }

    // .EcNack_ ecNack_ = 12;


    pub fn get_ecNack_(&self) -> &EcNack_ {
        self.ecNack_.as_ref().unwrap_or_else(|| EcNack_::default_instance())
    }
    pub fn clear_ecNack_(&mut self) {
        self.ecNack_.clear();
    }

    pub fn has_ecNack_(&self) -> bool {
        self.ecNack_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ecNack_(&mut self, v: EcNack_) {
        self.ecNack_ = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ecNack_(&mut self) -> &mut EcNack_ {
        if self.ecNack_.is_none() {
            self.ecNack_.set_default();
        }
        self.ecNack_.as_mut().unwrap()
    }

    // Take field
    pub fn take_ecNack_(&mut self) -> EcNack_ {
        self.ecNack_.take().unwrap_or_else(|| EcNack_::new())
    }

    // .EcNewEpoch_ ecNewEpoch_ = 13;


    pub fn get_ecNewEpoch_(&self) -> &EcNewEpoch_ {
        self.ecNewEpoch_.as_ref().unwrap_or_else(|| EcNewEpoch_::default_instance())
    }
    pub fn clear_ecNewEpoch_(&mut self) {
        self.ecNewEpoch_.clear();
    }

    pub fn has_ecNewEpoch_(&self) -> bool {
        self.ecNewEpoch_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ecNewEpoch_(&mut self, v: EcNewEpoch_) {
        self.ecNewEpoch_ = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ecNewEpoch_(&mut self) -> &mut EcNewEpoch_ {
        if self.ecNewEpoch_.is_none() {
            self.ecNewEpoch_.set_default();
        }
        self.ecNewEpoch_.as_mut().unwrap()
    }

    // Take field
    pub fn take_ecNewEpoch_(&mut self) -> EcNewEpoch_ {
        self.ecNewEpoch_.take().unwrap_or_else(|| EcNewEpoch_::new())
    }

    // .EcStartEpoch ecStartEpoch = 14;


    pub fn get_ecStartEpoch(&self) -> &EcStartEpoch {
        self.ecStartEpoch.as_ref().unwrap_or_else(|| EcStartEpoch::default_instance())
    }
    pub fn clear_ecStartEpoch(&mut self) {
        self.ecStartEpoch.clear();
    }

    pub fn has_ecStartEpoch(&self) -> bool {
        self.ecStartEpoch.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ecStartEpoch(&mut self, v: EcStartEpoch) {
        self.ecStartEpoch = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ecStartEpoch(&mut self) -> &mut EcStartEpoch {
        if self.ecStartEpoch.is_none() {
            self.ecStartEpoch.set_default();
        }
        self.ecStartEpoch.as_mut().unwrap()
    }

    // Take field
    pub fn take_ecStartEpoch(&mut self) -> EcStartEpoch {
        self.ecStartEpoch.take().unwrap_or_else(|| EcStartEpoch::new())
    }

    // .EldHeartbeat_ eldHeartbeat_ = 15;


    pub fn get_eldHeartbeat_(&self) -> &EldHeartbeat_ {
        self.eldHeartbeat_.as_ref().unwrap_or_else(|| EldHeartbeat_::default_instance())
    }
    pub fn clear_eldHeartbeat_(&mut self) {
        self.eldHeartbeat_.clear();
    }

    pub fn has_eldHeartbeat_(&self) -> bool {
        self.eldHeartbeat_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eldHeartbeat_(&mut self, v: EldHeartbeat_) {
        self.eldHeartbeat_ = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_eldHeartbeat_(&mut self) -> &mut EldHeartbeat_ {
        if self.eldHeartbeat_.is_none() {
            self.eldHeartbeat_.set_default();
        }
        self.eldHeartbeat_.as_mut().unwrap()
    }

    // Take field
    pub fn take_eldHeartbeat_(&mut self) -> EldHeartbeat_ {
        self.eldHeartbeat_.take().unwrap_or_else(|| EldHeartbeat_::new())
    }

    // .EldRecovery eldRecovery = 16;


    pub fn get_eldRecovery(&self) -> &EldRecovery {
        self.eldRecovery.as_ref().unwrap_or_else(|| EldRecovery::default_instance())
    }
    pub fn clear_eldRecovery(&mut self) {
        self.eldRecovery.clear();
    }

    pub fn has_eldRecovery(&self) -> bool {
        self.eldRecovery.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eldRecovery(&mut self, v: EldRecovery) {
        self.eldRecovery = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_eldRecovery(&mut self) -> &mut EldRecovery {
        if self.eldRecovery.is_none() {
            self.eldRecovery.set_default();
        }
        self.eldRecovery.as_mut().unwrap()
    }

    // Take field
    pub fn take_eldRecovery(&mut self) -> EldRecovery {
        self.eldRecovery.take().unwrap_or_else(|| EldRecovery::new())
    }

    // .EldTimeout eldTimeout = 17;


    pub fn get_eldTimeout(&self) -> &EldTimeout {
        self.eldTimeout.as_ref().unwrap_or_else(|| EldTimeout::default_instance())
    }
    pub fn clear_eldTimeout(&mut self) {
        self.eldTimeout.clear();
    }

    pub fn has_eldTimeout(&self) -> bool {
        self.eldTimeout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eldTimeout(&mut self, v: EldTimeout) {
        self.eldTimeout = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_eldTimeout(&mut self) -> &mut EldTimeout {
        if self.eldTimeout.is_none() {
            self.eldTimeout.set_default();
        }
        self.eldTimeout.as_mut().unwrap()
    }

    // Take field
    pub fn take_eldTimeout(&mut self) -> EldTimeout {
        self.eldTimeout.take().unwrap_or_else(|| EldTimeout::new())
    }

    // .EldTrust eldTrust = 18;


    pub fn get_eldTrust(&self) -> &EldTrust {
        self.eldTrust.as_ref().unwrap_or_else(|| EldTrust::default_instance())
    }
    pub fn clear_eldTrust(&mut self) {
        self.eldTrust.clear();
    }

    pub fn has_eldTrust(&self) -> bool {
        self.eldTrust.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eldTrust(&mut self, v: EldTrust) {
        self.eldTrust = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_eldTrust(&mut self) -> &mut EldTrust {
        if self.eldTrust.is_none() {
            self.eldTrust.set_default();
        }
        self.eldTrust.as_mut().unwrap()
    }

    // Take field
    pub fn take_eldTrust(&mut self) -> EldTrust {
        self.eldTrust.take().unwrap_or_else(|| EldTrust::new())
    }

    // .EpAbort epAbort = 19;


    pub fn get_epAbort(&self) -> &EpAbort {
        self.epAbort.as_ref().unwrap_or_else(|| EpAbort::default_instance())
    }
    pub fn clear_epAbort(&mut self) {
        self.epAbort.clear();
    }

    pub fn has_epAbort(&self) -> bool {
        self.epAbort.is_some()
    }

    // Param is passed by value, moved
    pub fn set_epAbort(&mut self, v: EpAbort) {
        self.epAbort = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_epAbort(&mut self) -> &mut EpAbort {
        if self.epAbort.is_none() {
            self.epAbort.set_default();
        }
        self.epAbort.as_mut().unwrap()
    }

    // Take field
    pub fn take_epAbort(&mut self) -> EpAbort {
        self.epAbort.take().unwrap_or_else(|| EpAbort::new())
    }

    // .EpAborted epAborted = 20;


    pub fn get_epAborted(&self) -> &EpAborted {
        self.epAborted.as_ref().unwrap_or_else(|| EpAborted::default_instance())
    }
    pub fn clear_epAborted(&mut self) {
        self.epAborted.clear();
    }

    pub fn has_epAborted(&self) -> bool {
        self.epAborted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_epAborted(&mut self, v: EpAborted) {
        self.epAborted = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_epAborted(&mut self) -> &mut EpAborted {
        if self.epAborted.is_none() {
            self.epAborted.set_default();
        }
        self.epAborted.as_mut().unwrap()
    }

    // Take field
    pub fn take_epAborted(&mut self) -> EpAborted {
        self.epAborted.take().unwrap_or_else(|| EpAborted::new())
    }

    // .EpAccept_ epAccept_ = 21;


    pub fn get_epAccept_(&self) -> &EpAccept_ {
        self.epAccept_.as_ref().unwrap_or_else(|| EpAccept_::default_instance())
    }
    pub fn clear_epAccept_(&mut self) {
        self.epAccept_.clear();
    }

    pub fn has_epAccept_(&self) -> bool {
        self.epAccept_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_epAccept_(&mut self, v: EpAccept_) {
        self.epAccept_ = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_epAccept_(&mut self) -> &mut EpAccept_ {
        if self.epAccept_.is_none() {
            self.epAccept_.set_default();
        }
        self.epAccept_.as_mut().unwrap()
    }

    // Take field
    pub fn take_epAccept_(&mut self) -> EpAccept_ {
        self.epAccept_.take().unwrap_or_else(|| EpAccept_::new())
    }

    // .EpDecide epDecide = 22;


    pub fn get_epDecide(&self) -> &EpDecide {
        self.epDecide.as_ref().unwrap_or_else(|| EpDecide::default_instance())
    }
    pub fn clear_epDecide(&mut self) {
        self.epDecide.clear();
    }

    pub fn has_epDecide(&self) -> bool {
        self.epDecide.is_some()
    }

    // Param is passed by value, moved
    pub fn set_epDecide(&mut self, v: EpDecide) {
        self.epDecide = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_epDecide(&mut self) -> &mut EpDecide {
        if self.epDecide.is_none() {
            self.epDecide.set_default();
        }
        self.epDecide.as_mut().unwrap()
    }

    // Take field
    pub fn take_epDecide(&mut self) -> EpDecide {
        self.epDecide.take().unwrap_or_else(|| EpDecide::new())
    }

    // .EpDecided_ epDecided_ = 23;


    pub fn get_epDecided_(&self) -> &EpDecided_ {
        self.epDecided_.as_ref().unwrap_or_else(|| EpDecided_::default_instance())
    }
    pub fn clear_epDecided_(&mut self) {
        self.epDecided_.clear();
    }

    pub fn has_epDecided_(&self) -> bool {
        self.epDecided_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_epDecided_(&mut self, v: EpDecided_) {
        self.epDecided_ = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_epDecided_(&mut self) -> &mut EpDecided_ {
        if self.epDecided_.is_none() {
            self.epDecided_.set_default();
        }
        self.epDecided_.as_mut().unwrap()
    }

    // Take field
    pub fn take_epDecided_(&mut self) -> EpDecided_ {
        self.epDecided_.take().unwrap_or_else(|| EpDecided_::new())
    }

    // .EpInit epInit = 24;


    pub fn get_epInit(&self) -> &EpInit {
        self.epInit.as_ref().unwrap_or_else(|| EpInit::default_instance())
    }
    pub fn clear_epInit(&mut self) {
        self.epInit.clear();
    }

    pub fn has_epInit(&self) -> bool {
        self.epInit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_epInit(&mut self, v: EpInit) {
        self.epInit = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_epInit(&mut self) -> &mut EpInit {
        if self.epInit.is_none() {
            self.epInit.set_default();
        }
        self.epInit.as_mut().unwrap()
    }

    // Take field
    pub fn take_epInit(&mut self) -> EpInit {
        self.epInit.take().unwrap_or_else(|| EpInit::new())
    }

    // .EpPropose epPropose = 25;


    pub fn get_epPropose(&self) -> &EpPropose {
        self.epPropose.as_ref().unwrap_or_else(|| EpPropose::default_instance())
    }
    pub fn clear_epPropose(&mut self) {
        self.epPropose.clear();
    }

    pub fn has_epPropose(&self) -> bool {
        self.epPropose.is_some()
    }

    // Param is passed by value, moved
    pub fn set_epPropose(&mut self, v: EpPropose) {
        self.epPropose = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_epPropose(&mut self) -> &mut EpPropose {
        if self.epPropose.is_none() {
            self.epPropose.set_default();
        }
        self.epPropose.as_mut().unwrap()
    }

    // Take field
    pub fn take_epPropose(&mut self) -> EpPropose {
        self.epPropose.take().unwrap_or_else(|| EpPropose::new())
    }

    // .EpRead_ epRead_ = 26;


    pub fn get_epRead_(&self) -> &EpRead_ {
        self.epRead_.as_ref().unwrap_or_else(|| EpRead_::default_instance())
    }
    pub fn clear_epRead_(&mut self) {
        self.epRead_.clear();
    }

    pub fn has_epRead_(&self) -> bool {
        self.epRead_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_epRead_(&mut self, v: EpRead_) {
        self.epRead_ = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_epRead_(&mut self) -> &mut EpRead_ {
        if self.epRead_.is_none() {
            self.epRead_.set_default();
        }
        self.epRead_.as_mut().unwrap()
    }

    // Take field
    pub fn take_epRead_(&mut self) -> EpRead_ {
        self.epRead_.take().unwrap_or_else(|| EpRead_::new())
    }

    // .EpState_ epState_ = 27;


    pub fn get_epState_(&self) -> &EpState_ {
        self.epState_.as_ref().unwrap_or_else(|| EpState_::default_instance())
    }
    pub fn clear_epState_(&mut self) {
        self.epState_.clear();
    }

    pub fn has_epState_(&self) -> bool {
        self.epState_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_epState_(&mut self, v: EpState_) {
        self.epState_ = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_epState_(&mut self) -> &mut EpState_ {
        if self.epState_.is_none() {
            self.epState_.set_default();
        }
        self.epState_.as_mut().unwrap()
    }

    // Take field
    pub fn take_epState_(&mut self) -> EpState_ {
        self.epState_.take().unwrap_or_else(|| EpState_::new())
    }

    // .EpWrite_ epWrite_ = 28;


    pub fn get_epWrite_(&self) -> &EpWrite_ {
        self.epWrite_.as_ref().unwrap_or_else(|| EpWrite_::default_instance())
    }
    pub fn clear_epWrite_(&mut self) {
        self.epWrite_.clear();
    }

    pub fn has_epWrite_(&self) -> bool {
        self.epWrite_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_epWrite_(&mut self, v: EpWrite_) {
        self.epWrite_ = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_epWrite_(&mut self) -> &mut EpWrite_ {
        if self.epWrite_.is_none() {
            self.epWrite_.set_default();
        }
        self.epWrite_.as_mut().unwrap()
    }

    // Take field
    pub fn take_epWrite_(&mut self) -> EpWrite_ {
        self.epWrite_.take().unwrap_or_else(|| EpWrite_::new())
    }

    // .PlDeliver plDeliver = 29;


    pub fn get_plDeliver(&self) -> &PlDeliver {
        self.plDeliver.as_ref().unwrap_or_else(|| PlDeliver::default_instance())
    }
    pub fn clear_plDeliver(&mut self) {
        self.plDeliver.clear();
    }

    pub fn has_plDeliver(&self) -> bool {
        self.plDeliver.is_some()
    }

    // Param is passed by value, moved
    pub fn set_plDeliver(&mut self, v: PlDeliver) {
        self.plDeliver = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_plDeliver(&mut self) -> &mut PlDeliver {
        if self.plDeliver.is_none() {
            self.plDeliver.set_default();
        }
        self.plDeliver.as_mut().unwrap()
    }

    // Take field
    pub fn take_plDeliver(&mut self) -> PlDeliver {
        self.plDeliver.take().unwrap_or_else(|| PlDeliver::new())
    }

    // .PlSend plSend = 30;


    pub fn get_plSend(&self) -> &PlSend {
        self.plSend.as_ref().unwrap_or_else(|| PlSend::default_instance())
    }
    pub fn clear_plSend(&mut self) {
        self.plSend.clear();
    }

    pub fn has_plSend(&self) -> bool {
        self.plSend.is_some()
    }

    // Param is passed by value, moved
    pub fn set_plSend(&mut self, v: PlSend) {
        self.plSend = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_plSend(&mut self) -> &mut PlSend {
        if self.plSend.is_none() {
            self.plSend.set_default();
        }
        self.plSend.as_mut().unwrap()
    }

    // Take field
    pub fn take_plSend(&mut self) -> PlSend {
        self.plSend.take().unwrap_or_else(|| PlSend::new())
    }

    // .UcDecide ucDecide = 31;


    pub fn get_ucDecide(&self) -> &UcDecide {
        self.ucDecide.as_ref().unwrap_or_else(|| UcDecide::default_instance())
    }
    pub fn clear_ucDecide(&mut self) {
        self.ucDecide.clear();
    }

    pub fn has_ucDecide(&self) -> bool {
        self.ucDecide.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ucDecide(&mut self, v: UcDecide) {
        self.ucDecide = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ucDecide(&mut self) -> &mut UcDecide {
        if self.ucDecide.is_none() {
            self.ucDecide.set_default();
        }
        self.ucDecide.as_mut().unwrap()
    }

    // Take field
    pub fn take_ucDecide(&mut self) -> UcDecide {
        self.ucDecide.take().unwrap_or_else(|| UcDecide::new())
    }

    // .UcPropose ucPropose = 32;


    pub fn get_ucPropose(&self) -> &UcPropose {
        self.ucPropose.as_ref().unwrap_or_else(|| UcPropose::default_instance())
    }
    pub fn clear_ucPropose(&mut self) {
        self.ucPropose.clear();
    }

    pub fn has_ucPropose(&self) -> bool {
        self.ucPropose.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ucPropose(&mut self, v: UcPropose) {
        self.ucPropose = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ucPropose(&mut self) -> &mut UcPropose {
        if self.ucPropose.is_none() {
            self.ucPropose.set_default();
        }
        self.ucPropose.as_mut().unwrap()
    }

    // Take field
    pub fn take_ucPropose(&mut self) -> UcPropose {
        self.ucPropose.take().unwrap_or_else(|| UcPropose::new())
    }

    // .ProcessId sender = 33;


    pub fn get_sender(&self) -> &ProcessId {
        self.sender.as_ref().unwrap_or_else(|| ProcessId::default_instance())
    }
    pub fn clear_sender(&mut self) {
        self.sender.clear();
    }

    pub fn has_sender(&self) -> bool {
        self.sender.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sender(&mut self, v: ProcessId) {
        self.sender = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sender(&mut self) -> &mut ProcessId {
        if self.sender.is_none() {
            self.sender.set_default();
        }
        self.sender.as_mut().unwrap()
    }

    // Take field
    pub fn take_sender(&mut self) -> ProcessId {
        self.sender.take().unwrap_or_else(|| ProcessId::new())
    }
}

impl ::protobuf::Message for Message {
    fn is_initialized(&self) -> bool {
        for v in &self.appRegistration {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.appPropose {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.appDecide {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.bebBroadcast {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.bebDeliver {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ecNack_ {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ecNewEpoch_ {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ecStartEpoch {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.eldHeartbeat_ {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.eldRecovery {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.eldTimeout {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.eldTrust {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.epAbort {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.epAborted {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.epAccept_ {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.epDecide {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.epDecided_ {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.epInit {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.epPropose {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.epRead_ {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.epState_ {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.epWrite_ {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.plDeliver {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.plSend {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ucDecide {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ucPropose {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.sender {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.messageUuid)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.abstractionId)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.systemId)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.appRegistration)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.appPropose)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.appDecide)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.bebBroadcast)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.bebDeliver)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ecNack_)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ecNewEpoch_)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ecStartEpoch)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.eldHeartbeat_)?;
                },
                16 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.eldRecovery)?;
                },
                17 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.eldTimeout)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.eldTrust)?;
                },
                19 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.epAbort)?;
                },
                20 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.epAborted)?;
                },
                21 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.epAccept_)?;
                },
                22 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.epDecide)?;
                },
                23 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.epDecided_)?;
                },
                24 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.epInit)?;
                },
                25 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.epPropose)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.epRead_)?;
                },
                27 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.epState_)?;
                },
                28 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.epWrite_)?;
                },
                29 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.plDeliver)?;
                },
                30 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.plSend)?;
                },
                31 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ucDecide)?;
                },
                32 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ucPropose)?;
                },
                33 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.sender)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.field_type != Message_Type::NONE {
            my_size += ::protobuf::rt::enum_size(1, self.field_type);
        }
        if !self.messageUuid.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.messageUuid);
        }
        if !self.abstractionId.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.abstractionId);
        }
        if !self.systemId.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.systemId);
        }
        if let Some(ref v) = self.appRegistration.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.appPropose.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.appDecide.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.bebBroadcast.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.bebDeliver.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.ecNack_.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.ecNewEpoch_.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.ecStartEpoch.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.eldHeartbeat_.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.eldRecovery.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.eldTimeout.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.eldTrust.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.epAbort.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.epAborted.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.epAccept_.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.epDecide.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.epDecided_.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.epInit.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.epPropose.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.epRead_.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.epState_.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.epWrite_.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.plDeliver.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.plSend.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.ucDecide.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.ucPropose.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.sender.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.field_type != Message_Type::NONE {
            os.write_enum(1, self.field_type.value())?;
        }
        if !self.messageUuid.is_empty() {
            os.write_string(2, &self.messageUuid)?;
        }
        if !self.abstractionId.is_empty() {
            os.write_string(3, &self.abstractionId)?;
        }
        if !self.systemId.is_empty() {
            os.write_string(4, &self.systemId)?;
        }
        if let Some(ref v) = self.appRegistration.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.appPropose.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.appDecide.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.bebBroadcast.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.bebDeliver.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.ecNack_.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.ecNewEpoch_.as_ref() {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.ecStartEpoch.as_ref() {
            os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.eldHeartbeat_.as_ref() {
            os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.eldRecovery.as_ref() {
            os.write_tag(16, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.eldTimeout.as_ref() {
            os.write_tag(17, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.eldTrust.as_ref() {
            os.write_tag(18, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.epAbort.as_ref() {
            os.write_tag(19, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.epAborted.as_ref() {
            os.write_tag(20, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.epAccept_.as_ref() {
            os.write_tag(21, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.epDecide.as_ref() {
            os.write_tag(22, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.epDecided_.as_ref() {
            os.write_tag(23, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.epInit.as_ref() {
            os.write_tag(24, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.epPropose.as_ref() {
            os.write_tag(25, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.epRead_.as_ref() {
            os.write_tag(26, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.epState_.as_ref() {
            os.write_tag(27, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.epWrite_.as_ref() {
            os.write_tag(28, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.plDeliver.as_ref() {
            os.write_tag(29, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.plSend.as_ref() {
            os.write_tag(30, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.ucDecide.as_ref() {
            os.write_tag(31, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.ucPropose.as_ref() {
            os.write_tag(32, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.sender.as_ref() {
            os.write_tag(33, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Message {
        Message::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Message_Type>>(
                    "type",
                    |m: &Message| { &m.field_type },
                    |m: &mut Message| { &mut m.field_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "messageUuid",
                    |m: &Message| { &m.messageUuid },
                    |m: &mut Message| { &mut m.messageUuid },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "abstractionId",
                    |m: &Message| { &m.abstractionId },
                    |m: &mut Message| { &mut m.abstractionId },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "systemId",
                    |m: &Message| { &m.systemId },
                    |m: &mut Message| { &mut m.systemId },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AppRegistration>>(
                    "appRegistration",
                    |m: &Message| { &m.appRegistration },
                    |m: &mut Message| { &mut m.appRegistration },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AppPropose>>(
                    "appPropose",
                    |m: &Message| { &m.appPropose },
                    |m: &mut Message| { &mut m.appPropose },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AppDecide>>(
                    "appDecide",
                    |m: &Message| { &m.appDecide },
                    |m: &mut Message| { &mut m.appDecide },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BebBroadcast>>(
                    "bebBroadcast",
                    |m: &Message| { &m.bebBroadcast },
                    |m: &mut Message| { &mut m.bebBroadcast },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BebDeliver>>(
                    "bebDeliver",
                    |m: &Message| { &m.bebDeliver },
                    |m: &mut Message| { &mut m.bebDeliver },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EcNack_>>(
                    "ecNack_",
                    |m: &Message| { &m.ecNack_ },
                    |m: &mut Message| { &mut m.ecNack_ },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EcNewEpoch_>>(
                    "ecNewEpoch_",
                    |m: &Message| { &m.ecNewEpoch_ },
                    |m: &mut Message| { &mut m.ecNewEpoch_ },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EcStartEpoch>>(
                    "ecStartEpoch",
                    |m: &Message| { &m.ecStartEpoch },
                    |m: &mut Message| { &mut m.ecStartEpoch },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EldHeartbeat_>>(
                    "eldHeartbeat_",
                    |m: &Message| { &m.eldHeartbeat_ },
                    |m: &mut Message| { &mut m.eldHeartbeat_ },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EldRecovery>>(
                    "eldRecovery",
                    |m: &Message| { &m.eldRecovery },
                    |m: &mut Message| { &mut m.eldRecovery },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EldTimeout>>(
                    "eldTimeout",
                    |m: &Message| { &m.eldTimeout },
                    |m: &mut Message| { &mut m.eldTimeout },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EldTrust>>(
                    "eldTrust",
                    |m: &Message| { &m.eldTrust },
                    |m: &mut Message| { &mut m.eldTrust },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EpAbort>>(
                    "epAbort",
                    |m: &Message| { &m.epAbort },
                    |m: &mut Message| { &mut m.epAbort },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EpAborted>>(
                    "epAborted",
                    |m: &Message| { &m.epAborted },
                    |m: &mut Message| { &mut m.epAborted },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EpAccept_>>(
                    "epAccept_",
                    |m: &Message| { &m.epAccept_ },
                    |m: &mut Message| { &mut m.epAccept_ },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EpDecide>>(
                    "epDecide",
                    |m: &Message| { &m.epDecide },
                    |m: &mut Message| { &mut m.epDecide },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EpDecided_>>(
                    "epDecided_",
                    |m: &Message| { &m.epDecided_ },
                    |m: &mut Message| { &mut m.epDecided_ },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EpInit>>(
                    "epInit",
                    |m: &Message| { &m.epInit },
                    |m: &mut Message| { &mut m.epInit },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EpPropose>>(
                    "epPropose",
                    |m: &Message| { &m.epPropose },
                    |m: &mut Message| { &mut m.epPropose },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EpRead_>>(
                    "epRead_",
                    |m: &Message| { &m.epRead_ },
                    |m: &mut Message| { &mut m.epRead_ },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EpState_>>(
                    "epState_",
                    |m: &Message| { &m.epState_ },
                    |m: &mut Message| { &mut m.epState_ },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EpWrite_>>(
                    "epWrite_",
                    |m: &Message| { &m.epWrite_ },
                    |m: &mut Message| { &mut m.epWrite_ },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PlDeliver>>(
                    "plDeliver",
                    |m: &Message| { &m.plDeliver },
                    |m: &mut Message| { &mut m.plDeliver },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PlSend>>(
                    "plSend",
                    |m: &Message| { &m.plSend },
                    |m: &mut Message| { &mut m.plSend },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UcDecide>>(
                    "ucDecide",
                    |m: &Message| { &m.ucDecide },
                    |m: &mut Message| { &mut m.ucDecide },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UcPropose>>(
                    "ucPropose",
                    |m: &Message| { &m.ucPropose },
                    |m: &mut Message| { &mut m.ucPropose },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ProcessId>>(
                    "sender",
                    |m: &Message| { &m.sender },
                    |m: &mut Message| { &mut m.sender },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Message>(
                    "Message",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Message {
        static mut instance: ::protobuf::lazy::Lazy<Message> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(Message::new)
        }
    }
}

impl ::protobuf::Clear for Message {
    fn clear(&mut self) {
        self.field_type = Message_Type::NONE;
        self.messageUuid.clear();
        self.abstractionId.clear();
        self.systemId.clear();
        self.appRegistration.clear();
        self.appPropose.clear();
        self.appDecide.clear();
        self.bebBroadcast.clear();
        self.bebDeliver.clear();
        self.ecNack_.clear();
        self.ecNewEpoch_.clear();
        self.ecStartEpoch.clear();
        self.eldHeartbeat_.clear();
        self.eldRecovery.clear();
        self.eldTimeout.clear();
        self.eldTrust.clear();
        self.epAbort.clear();
        self.epAborted.clear();
        self.epAccept_.clear();
        self.epDecide.clear();
        self.epDecided_.clear();
        self.epInit.clear();
        self.epPropose.clear();
        self.epRead_.clear();
        self.epState_.clear();
        self.epWrite_.clear();
        self.plDeliver.clear();
        self.plSend.clear();
        self.ucDecide.clear();
        self.ucPropose.clear();
        self.sender.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Message {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Message {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Message_Type {
    NONE = 0,
    APP_REGISTRATION = 5,
    APP_PROPOSE = 6,
    APP_DECIDE = 7,
    BEB_BROADCAST = 10,
    BEB_DELIVER = 11,
    EC_NACK_ = 12,
    EC_NEW_EPOCH_ = 13,
    EC_START_EPOCH = 14,
    ELD_HEARTBEAT_ = 15,
    ELD_RECOVERY = 16,
    ELD_TIMEOUT = 17,
    ELD_TRUST = 18,
    EP_ABORT = 19,
    EP_ABORTED = 20,
    EP_ACCEPT_ = 21,
    EP_DECIDE = 22,
    EP_DECIDED_ = 23,
    EP_INIT = 24,
    EP_PROPOSE = 25,
    EP_READ_ = 26,
    EP_STATE_ = 27,
    EP_WRITE_ = 28,
    PL_DELIVER = 29,
    PL_SEND = 30,
    UC_DECIDE = 31,
    UC_PROPOSE = 32,
}

impl ::protobuf::ProtobufEnum for Message_Type {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Message_Type> {
        match value {
            0 => ::std::option::Option::Some(Message_Type::NONE),
            5 => ::std::option::Option::Some(Message_Type::APP_REGISTRATION),
            6 => ::std::option::Option::Some(Message_Type::APP_PROPOSE),
            7 => ::std::option::Option::Some(Message_Type::APP_DECIDE),
            10 => ::std::option::Option::Some(Message_Type::BEB_BROADCAST),
            11 => ::std::option::Option::Some(Message_Type::BEB_DELIVER),
            12 => ::std::option::Option::Some(Message_Type::EC_NACK_),
            13 => ::std::option::Option::Some(Message_Type::EC_NEW_EPOCH_),
            14 => ::std::option::Option::Some(Message_Type::EC_START_EPOCH),
            15 => ::std::option::Option::Some(Message_Type::ELD_HEARTBEAT_),
            16 => ::std::option::Option::Some(Message_Type::ELD_RECOVERY),
            17 => ::std::option::Option::Some(Message_Type::ELD_TIMEOUT),
            18 => ::std::option::Option::Some(Message_Type::ELD_TRUST),
            19 => ::std::option::Option::Some(Message_Type::EP_ABORT),
            20 => ::std::option::Option::Some(Message_Type::EP_ABORTED),
            21 => ::std::option::Option::Some(Message_Type::EP_ACCEPT_),
            22 => ::std::option::Option::Some(Message_Type::EP_DECIDE),
            23 => ::std::option::Option::Some(Message_Type::EP_DECIDED_),
            24 => ::std::option::Option::Some(Message_Type::EP_INIT),
            25 => ::std::option::Option::Some(Message_Type::EP_PROPOSE),
            26 => ::std::option::Option::Some(Message_Type::EP_READ_),
            27 => ::std::option::Option::Some(Message_Type::EP_STATE_),
            28 => ::std::option::Option::Some(Message_Type::EP_WRITE_),
            29 => ::std::option::Option::Some(Message_Type::PL_DELIVER),
            30 => ::std::option::Option::Some(Message_Type::PL_SEND),
            31 => ::std::option::Option::Some(Message_Type::UC_DECIDE),
            32 => ::std::option::Option::Some(Message_Type::UC_PROPOSE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Message_Type] = &[
            Message_Type::NONE,
            Message_Type::APP_REGISTRATION,
            Message_Type::APP_PROPOSE,
            Message_Type::APP_DECIDE,
            Message_Type::BEB_BROADCAST,
            Message_Type::BEB_DELIVER,
            Message_Type::EC_NACK_,
            Message_Type::EC_NEW_EPOCH_,
            Message_Type::EC_START_EPOCH,
            Message_Type::ELD_HEARTBEAT_,
            Message_Type::ELD_RECOVERY,
            Message_Type::ELD_TIMEOUT,
            Message_Type::ELD_TRUST,
            Message_Type::EP_ABORT,
            Message_Type::EP_ABORTED,
            Message_Type::EP_ACCEPT_,
            Message_Type::EP_DECIDE,
            Message_Type::EP_DECIDED_,
            Message_Type::EP_INIT,
            Message_Type::EP_PROPOSE,
            Message_Type::EP_READ_,
            Message_Type::EP_STATE_,
            Message_Type::EP_WRITE_,
            Message_Type::PL_DELIVER,
            Message_Type::PL_SEND,
            Message_Type::UC_DECIDE,
            Message_Type::UC_PROPOSE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Message_Type", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Message_Type {
}

impl ::std::default::Default for Message_Type {
    fn default() -> Self {
        Message_Type::NONE
    }
}

impl ::protobuf::reflect::ProtobufValue for Message_Type {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(self.descriptor())
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\rmessage.proto\"s\n\tProcessId\x12\x12\n\x04host\x18\x01\x20\x01(\tR\
    \x04host\x12\x12\n\x04port\x18\x02\x20\x01(\x05R\x04port\x12\x14\n\x05ow\
    ner\x18\x03\x20\x01(\tR\x05owner\x12\x14\n\x05index\x18\x04\x20\x01(\x05\
    R\x05index\x12\x12\n\x04rank\x18\x05\x20\x01(\x05R\x04rank\"!\n\tUcPropo\
    se\x12\x14\n\x05value\x18\x01\x20\x01(\x05R\x05value\"\\\n\x0cEcStartEpo\
    ch\x12\"\n\x0cnewTimestamp\x18\x01\x20\x01(\x05R\x0cnewTimestamp\x12(\n\
    \tnewLeader\x18\x02\x20\x01(\x0b2\n.ProcessIdR\tnewLeader\"\t\n\x07EpAbo\
    rt\"F\n\x06EpInit\x12&\n\x0evalueTimestamp\x18\x01\x20\x01(\x05R\x0evalu\
    eTimestamp\x12\x14\n\x05value\x18\x02\x20\x01(\x05R\x05value\"I\n\tEpAbo\
    rted\x12&\n\x0evalueTimestamp\x18\x01\x20\x01(\x05R\x0evalueTimestamp\
    \x12\x14\n\x05value\x18\x02\x20\x01(\x05R\x05value\"!\n\tEpPropose\x12\
    \x14\n\x05value\x18\x01\x20\x01(\x05R\x05value\"\x20\n\x08EpDecide\x12\
    \x14\n\x05value\x18\x01\x20\x01(\x05R\x05value\"\x20\n\x08UcDecide\x12\
    \x14\n\x05value\x18\x01\x20\x01(\x05R\x05value\"\t\n\x07EpRead_\"H\n\x08\
    EpState_\x12&\n\x0evalueTimestamp\x18\x01\x20\x01(\x05R\x0evalueTimestam\
    p\x12\x14\n\x05value\x18\x02\x20\x01(\x05R\x05value\"\x20\n\x08EpWrite_\
    \x12\x14\n\x05value\x18\x01\x20\x01(\x05R\x05value\"\x0b\n\tEpAccept_\"\
    \"\n\nEpDecided_\x12\x14\n\x05value\x18\x01\x20\x01(\x05R\x05value\"+\n\
    \x0bEcNewEpoch_\x12\x1c\n\ttimestamp\x18\x01\x20\x01(\x05R\ttimestamp\"\
    \t\n\x07EcNack_\"2\n\x0cBebBroadcast\x12\"\n\x07message\x18\x01\x20\x01(\
    \x0b2\x08.MessageR\x07message\"T\n\nBebDeliver\x12\"\n\x07message\x18\
    \x01\x20\x01(\x0b2\x08.MessageR\x07message\x12\"\n\x06sender\x18\x02\x20\
    \x01(\x0b2\n.ProcessIdR\x06sender\"\r\n\x0bEldRecovery\"\x0c\n\nEldTimeo\
    ut\"4\n\x08EldTrust\x12(\n\tprocessId\x18\x01\x20\x01(\x0b2\n.ProcessIdR\
    \tprocessId\"%\n\rEldHeartbeat_\x12\x14\n\x05epoch\x18\x01\x20\x01(\x05R\
    \x05epoch\",\n\x06PlSend\x12\"\n\x07message\x18\x01\x20\x01(\x0b2\x08.Me\
    ssageR\x07message\"S\n\tPlDeliver\x12\"\n\x07message\x18\x01\x20\x01(\
    \x0b2\x08.MessageR\x07message\x12\"\n\x06sender\x18\x02\x20\x01(\x0b2\n.\
    ProcessIdR\x06sender\"Q\n\x0fAppRegistration\x12\x14\n\x05owner\x18\x01\
    \x20\x01(\tR\x05owner\x12\x14\n\x05index\x18\x02\x20\x01(\x05R\x05index\
    \x12\x12\n\x04port\x18\x03\x20\x01(\x05R\x04port\"L\n\nAppPropose\x12\
    \x14\n\x05value\x18\x01\x20\x01(\x05R\x05value\x12(\n\tprocesses\x18\x02\
    \x20\x03(\x0b2\n.ProcessIdR\tprocesses\"!\n\tAppDecide\x12\x14\n\x05valu\
    e\x18\x01\x20\x01(\x05R\x05value\"\xc1\r\n\x07Message\x12!\n\x04type\x18\
    \x01\x20\x01(\x0e2\r.Message.TypeR\x04type\x12\x20\n\x0bmessageUuid\x18\
    \x02\x20\x01(\tR\x0bmessageUuid\x12$\n\rabstractionId\x18\x03\x20\x01(\t\
    R\rabstractionId\x12\x1a\n\x08systemId\x18\x04\x20\x01(\tR\x08systemId\
    \x12:\n\x0fappRegistration\x18\x05\x20\x01(\x0b2\x10.AppRegistrationR\
    \x0fappRegistration\x12+\n\nappPropose\x18\x06\x20\x01(\x0b2\x0b.AppProp\
    oseR\nappPropose\x12(\n\tappDecide\x18\x07\x20\x01(\x0b2\n.AppDecideR\ta\
    ppDecide\x121\n\x0cbebBroadcast\x18\n\x20\x01(\x0b2\r.BebBroadcastR\x0cb\
    ebBroadcast\x12+\n\nbebDeliver\x18\x0b\x20\x01(\x0b2\x0b.BebDeliverR\nbe\
    bDeliver\x12!\n\x07ecNack_\x18\x0c\x20\x01(\x0b2\x08.EcNack_R\x06ecNack\
    \x12-\n\x0becNewEpoch_\x18\r\x20\x01(\x0b2\x0c.EcNewEpoch_R\necNewEpoch\
    \x121\n\x0cecStartEpoch\x18\x0e\x20\x01(\x0b2\r.EcStartEpochR\x0cecStart\
    Epoch\x123\n\reldHeartbeat_\x18\x0f\x20\x01(\x0b2\x0e.EldHeartbeat_R\x0c\
    eldHeartbeat\x12.\n\x0beldRecovery\x18\x10\x20\x01(\x0b2\x0c.EldRecovery\
    R\x0beldRecovery\x12+\n\neldTimeout\x18\x11\x20\x01(\x0b2\x0b.EldTimeout\
    R\neldTimeout\x12%\n\x08eldTrust\x18\x12\x20\x01(\x0b2\t.EldTrustR\x08el\
    dTrust\x12\"\n\x07epAbort\x18\x13\x20\x01(\x0b2\x08.EpAbortR\x07epAbort\
    \x12(\n\tepAborted\x18\x14\x20\x01(\x0b2\n.EpAbortedR\tepAborted\x12'\n\
    \tepAccept_\x18\x15\x20\x01(\x0b2\n.EpAccept_R\x08epAccept\x12%\n\x08epD\
    ecide\x18\x16\x20\x01(\x0b2\t.EpDecideR\x08epDecide\x12*\n\nepDecided_\
    \x18\x17\x20\x01(\x0b2\x0b.EpDecided_R\tepDecided\x12\x1f\n\x06epInit\
    \x18\x18\x20\x01(\x0b2\x07.EpInitR\x06epInit\x12(\n\tepPropose\x18\x19\
    \x20\x01(\x0b2\n.EpProposeR\tepPropose\x12!\n\x07epRead_\x18\x1a\x20\x01\
    (\x0b2\x08.EpRead_R\x06epRead\x12$\n\x08epState_\x18\x1b\x20\x01(\x0b2\t\
    .EpState_R\x07epState\x12$\n\x08epWrite_\x18\x1c\x20\x01(\x0b2\t.EpWrite\
    _R\x07epWrite\x12(\n\tplDeliver\x18\x1d\x20\x01(\x0b2\n.PlDeliverR\tplDe\
    liver\x12\x1f\n\x06plSend\x18\x1e\x20\x01(\x0b2\x07.PlSendR\x06plSend\
    \x12%\n\x08ucDecide\x18\x1f\x20\x01(\x0b2\t.UcDecideR\x08ucDecide\x12(\n\
    \tucPropose\x18\x20\x20\x01(\x0b2\n.UcProposeR\tucPropose\x12\"\n\x06sen\
    der\x18!\x20\x01(\x0b2\n.ProcessIdR\x06sender\"\xb9\x03\n\x04Type\x12\
    \x08\n\x04NONE\x10\0\x12\x14\n\x10APP_REGISTRATION\x10\x05\x12\x0f\n\x0b\
    APP_PROPOSE\x10\x06\x12\x0e\n\nAPP_DECIDE\x10\x07\x12\x11\n\rBEB_BROADCA\
    ST\x10\n\x12\x0f\n\x0bBEB_DELIVER\x10\x0b\x12\x0c\n\x08EC_NACK_\x10\x0c\
    \x12\x11\n\rEC_NEW_EPOCH_\x10\r\x12\x12\n\x0eEC_START_EPOCH\x10\x0e\x12\
    \x12\n\x0eELD_HEARTBEAT_\x10\x0f\x12\x10\n\x0cELD_RECOVERY\x10\x10\x12\
    \x0f\n\x0bELD_TIMEOUT\x10\x11\x12\r\n\tELD_TRUST\x10\x12\x12\x0c\n\x08EP\
    _ABORT\x10\x13\x12\x0e\n\nEP_ABORTED\x10\x14\x12\x0e\n\nEP_ACCEPT_\x10\
    \x15\x12\r\n\tEP_DECIDE\x10\x16\x12\x0f\n\x0bEP_DECIDED_\x10\x17\x12\x0b\
    \n\x07EP_INIT\x10\x18\x12\x0e\n\nEP_PROPOSE\x10\x19\x12\x0c\n\x08EP_READ\
    _\x10\x1a\x12\r\n\tEP_STATE_\x10\x1b\x12\r\n\tEP_WRITE_\x10\x1c\x12\x0e\
    \n\nPL_DELIVER\x10\x1d\x12\x0b\n\x07PL_SEND\x10\x1e\x12\r\n\tUC_DECIDE\
    \x10\x1f\x12\x0e\n\nUC_PROPOSE\x10\x20b\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
